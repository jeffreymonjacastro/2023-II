$date
	Sat Nov 11 11:48:26 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module testbench $end
$var wire 32 ! WriteData [31:0] $end
$var wire 1 " MemWrite $end
$var wire 32 # DataAdr [31:0] $end
$var reg 1 $ clk $end
$var reg 1 % reset $end
$scope module dut $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 32 & WriteData [31:0] $end
$var wire 32 ' ReadData [31:0] $end
$var wire 1 " MemWrite $end
$var wire 32 ( Adr [31:0] $end
$scope module arm $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 32 ) WriteData [31:0] $end
$var wire 2 * ResultSrc [1:0] $end
$var wire 1 + RegWrite $end
$var wire 2 , RegSrc [1:0] $end
$var wire 32 - ReadData [31:0] $end
$var wire 1 . PCWrite $end
$var wire 1 " MemWrite $end
$var wire 32 / Instr [31:0] $end
$var wire 2 0 ImmSrc [1:0] $end
$var wire 1 1 IRWrite $end
$var wire 1 2 AdrSrc $end
$var wire 32 3 Adr [31:0] $end
$var wire 2 4 ALUSrcB [1:0] $end
$var wire 2 5 ALUSrcA [1:0] $end
$var wire 4 6 ALUFlags [3:0] $end
$var wire 2 7 ALUControl [1:0] $end
$scope module c $end
$var wire 20 8 Instr [31:12] $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 2 9 ResultSrc [1:0] $end
$var wire 1 + RegWrite $end
$var wire 1 : RegW $end
$var wire 2 ; RegSrc [1:0] $end
$var wire 1 . PCWrite $end
$var wire 1 < PCS $end
$var wire 1 = NextPC $end
$var wire 1 " MemWrite $end
$var wire 1 > MemW $end
$var wire 2 ? ImmSrc [1:0] $end
$var wire 1 1 IRWrite $end
$var wire 2 @ FlagW [1:0] $end
$var wire 1 2 AdrSrc $end
$var wire 2 A ALUSrcB [1:0] $end
$var wire 2 B ALUSrcA [1:0] $end
$var wire 4 C ALUFlags [3:0] $end
$var wire 2 D ALUControl [1:0] $end
$scope module cl $end
$var wire 4 E Cond [3:0] $end
$var wire 2 F FlagWrite [1:0] $end
$var wire 1 " MemWrite $end
$var wire 1 . PCWrite $end
$var wire 1 + RegWrite $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 1 : RegW $end
$var wire 1 < PCS $end
$var wire 1 = NextPC $end
$var wire 1 > MemW $end
$var wire 4 G Flags [3:0] $end
$var wire 2 H FlagW [1:0] $end
$var wire 1 I CondExDelayed $end
$var wire 1 J CondEx $end
$var wire 4 K ALUFlags [3:0] $end
$scope module cc $end
$var wire 4 L Cond [3:0] $end
$var wire 4 M Flags [3:0] $end
$var wire 1 N ge $end
$var wire 1 O zero $end
$var wire 1 P overflow $end
$var wire 1 Q neg $end
$var wire 1 R carry $end
$var reg 1 J CondEx $end
$upscope $end
$scope module condreg $end
$var wire 1 $ clk $end
$var wire 1 J d $end
$var wire 1 % reset $end
$var reg 1 I q $end
$upscope $end
$scope module flagreg0 $end
$var wire 1 $ clk $end
$var wire 2 S d [1:0] $end
$var wire 1 T en $end
$var wire 1 % reset $end
$var reg 2 U q [1:0] $end
$upscope $end
$scope module flagreg1 $end
$var wire 1 $ clk $end
$var wire 2 V d [1:0] $end
$var wire 1 W en $end
$var wire 1 % reset $end
$var reg 2 X q [1:0] $end
$upscope $end
$upscope $end
$scope module dec $end
$var wire 6 Y Funct [5:0] $end
$var wire 2 Z ImmSrc [1:0] $end
$var wire 2 [ Op [1:0] $end
$var wire 1 < PCS $end
$var wire 4 \ Rd [3:0] $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 2 ] ResultSrc [1:0] $end
$var wire 1 : RegW $end
$var wire 2 ^ RegSrc [1:0] $end
$var wire 1 = NextPC $end
$var wire 1 > MemW $end
$var wire 1 1 IRWrite $end
$var wire 1 _ Branch $end
$var wire 1 2 AdrSrc $end
$var wire 2 ` ALUSrcB [1:0] $end
$var wire 2 a ALUSrcA [1:0] $end
$var wire 1 b ALUOp $end
$var reg 2 c ALUControl [1:0] $end
$var reg 2 d FlagW [1:0] $end
$scope module fsm $end
$var wire 6 e Funct [5:0] $end
$var wire 2 f Op [1:0] $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 2 g ResultSrc [1:0] $end
$var wire 1 : RegW $end
$var wire 1 = NextPC $end
$var wire 1 > MemW $end
$var wire 1 1 IRWrite $end
$var wire 1 _ Branch $end
$var wire 1 2 AdrSrc $end
$var wire 2 h ALUSrcB [1:0] $end
$var wire 2 i ALUSrcA [1:0] $end
$var wire 1 b ALUOp $end
$var reg 13 j controls [12:0] $end
$var reg 4 k nextstate [3:0] $end
$var reg 4 l state [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module dp $end
$var wire 2 m ALUControl [1:0] $end
$var wire 2 n ALUSrcA [1:0] $end
$var wire 2 o ALUSrcB [1:0] $end
$var wire 1 2 AdrSrc $end
$var wire 1 1 IRWrite $end
$var wire 2 p ImmSrc [1:0] $end
$var wire 1 . PCWrite $end
$var wire 2 q RegSrc [1:0] $end
$var wire 1 + RegWrite $end
$var wire 2 r ResultSrc [1:0] $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 32 s WriteData [31:0] $end
$var wire 32 t SrcB [31:0] $end
$var wire 32 u SrcA [31:0] $end
$var wire 32 v Result [31:0] $end
$var wire 32 w ReadData [31:0] $end
$var wire 32 x RD2 [31:0] $end
$var wire 32 y RD1 [31:0] $end
$var wire 4 z RA2 [3:0] $end
$var wire 4 { RA1 [3:0] $end
$var wire 32 | PC [31:0] $end
$var wire 32 } Instr [31:0] $end
$var wire 32 ~ ExtImm [31:0] $end
$var wire 32 !" Data [31:0] $end
$var wire 32 "" Adr [31:0] $end
$var wire 32 #" ALUResult [31:0] $end
$var wire 32 $" ALUOut [31:0] $end
$var wire 4 %" ALUFlags [3:0] $end
$var wire 32 &" A [31:0] $end
$scope module adrmux $end
$var wire 1 2 s $end
$var wire 32 '" y [31:0] $end
$var wire 32 (" d1 [31:0] $end
$var wire 32 )" d0 [31:0] $end
$upscope $end
$scope module alu $end
$var wire 2 *" ALUControl [1:0] $end
$var wire 1 +" carry $end
$var wire 1 ," overflow $end
$var wire 1 -" zero $end
$var wire 33 ." sum [32:0] $end
$var wire 1 /" negative $end
$var wire 32 0" b [31:0] $end
$var wire 32 1" a [31:0] $end
$var wire 4 2" ALUFlags [3:0] $end
$var reg 32 3" Result [31:0] $end
$upscope $end
$scope module aluoutreg $end
$var wire 1 $ clk $end
$var wire 32 4" d [31:0] $end
$var wire 1 % reset $end
$var reg 32 5" q [31:0] $end
$upscope $end
$scope module datareg $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 32 6" d [31:0] $end
$var reg 32 7" q [31:0] $end
$upscope $end
$scope module ext $end
$var wire 2 8" ImmSrc [1:0] $end
$var wire 24 9" Instr [23:0] $end
$var reg 32 :" ExtImm [31:0] $end
$upscope $end
$scope module ir $end
$var wire 1 $ clk $end
$var wire 1 1 en $end
$var wire 1 % reset $end
$var wire 32 ;" d [31:0] $end
$var reg 32 <" q [31:0] $end
$upscope $end
$scope module pcreg $end
$var wire 1 $ clk $end
$var wire 1 . en $end
$var wire 1 % reset $end
$var wire 32 =" d [31:0] $end
$var reg 32 >" q [31:0] $end
$upscope $end
$scope module ra1mux $end
$var wire 4 ?" d0 [3:0] $end
$var wire 4 @" d1 [3:0] $end
$var wire 1 A" s $end
$var wire 4 B" y [3:0] $end
$upscope $end
$scope module ra2mux $end
$var wire 4 C" d0 [3:0] $end
$var wire 4 D" d1 [3:0] $end
$var wire 1 E" s $end
$var wire 4 F" y [3:0] $end
$upscope $end
$scope module resmux $end
$var wire 32 G" d0 [31:0] $end
$var wire 32 H" d1 [31:0] $end
$var wire 32 I" d2 [31:0] $end
$var wire 2 J" s [1:0] $end
$var wire 32 K" y [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 $ clk $end
$var wire 32 L" r15 [31:0] $end
$var wire 4 M" ra1 [3:0] $end
$var wire 4 N" ra2 [3:0] $end
$var wire 4 O" wa3 [3:0] $end
$var wire 32 P" wd3 [31:0] $end
$var wire 1 + we3 $end
$var wire 32 Q" rd2 [31:0] $end
$var wire 32 R" rd1 [31:0] $end
$upscope $end
$scope module srcamux $end
$var wire 32 S" d1 [31:0] $end
$var wire 32 T" d2 [31:0] $end
$var wire 2 U" s [1:0] $end
$var wire 32 V" y [31:0] $end
$var wire 32 W" d0 [31:0] $end
$upscope $end
$scope module srcareg $end
$var wire 1 $ clk $end
$var wire 32 X" d [31:0] $end
$var wire 1 % reset $end
$var reg 32 Y" q [31:0] $end
$upscope $end
$scope module srcbmux $end
$var wire 32 Z" d1 [31:0] $end
$var wire 32 [" d2 [31:0] $end
$var wire 2 \" s [1:0] $end
$var wire 32 ]" y [31:0] $end
$var wire 32 ^" d0 [31:0] $end
$upscope $end
$scope module wdreg $end
$var wire 1 $ clk $end
$var wire 32 _" d [31:0] $end
$var wire 1 % reset $end
$var reg 32 `" q [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mem $end
$var wire 32 a" a [31:0] $end
$var wire 1 $ clk $end
$var wire 32 b" rd [31:0] $end
$var wire 32 c" wd [31:0] $end
$var wire 1 " we $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 c"
b11100000010011110000000000001111 b"
b0 a"
b0 `"
bx _"
b0 ^"
b100 ]"
b10 \"
b100 ["
b0 Z"
b0 Y"
bx X"
b0 W"
b0 V"
b1 U"
b0 T"
b0 S"
bx R"
bx Q"
b100 P"
b0 O"
b0 N"
b0 M"
b100 L"
b100 K"
b10 J"
b100 I"
b0 H"
b0 G"
b0 F"
0E"
b0 D"
b0 C"
b0 B"
0A"
b1111 @"
b0 ?"
b0 >"
b100 ="
b0 <"
b11100000010011110000000000001111 ;"
b0 :"
b0 9"
b0 8"
b0 7"
b11100000010011110000000000001111 6"
b0 5"
b100 4"
b100 3"
b0 2"
b0 1"
b100 0"
0/"
b100 ."
0-"
0,"
0+"
b0 *"
b0 )"
b0 ("
b0 '"
b0 &"
b0 %"
b0 $"
b100 #"
b0 ""
b0 !"
b0 ~
b0 }
b0 |
b0 {
b0 z
bx y
bx x
b11100000010011110000000000001111 w
b100 v
b0 u
b100 t
b0 s
b10 r
b0 q
b0 p
b10 o
b1 n
b0 m
b0 l
b1 k
b1000101001100 j
b1 i
b10 h
b10 g
b0 f
b0 e
b0 d
b0 c
0b
b1 a
b10 `
0_
b0 ^
b10 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
0W
b0 V
b0 U
0T
b0 S
0R
0Q
0P
0O
1N
b0 M
b0 L
b0 K
0J
0I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b1 B
b10 A
b0 @
b0 ?
0>
1=
0<
b0 ;
0:
b10 9
b0 8
b0 7
b0 6
b1 5
b10 4
b0 3
02
11
b0 0
b0 /
1.
b11100000010011110000000000001111 -
b0 ,
0+
b10 *
b0 )
b0 (
b11100000010011110000000000001111 '
b0 &
1%
1$
b0 #
0"
b0 !
$end
